package sort;

pub fn swap(arr: [Int], i: Int, j: Int) -> Void {
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
    return null;
}

pub fn reverse(arr: [Int]) -> [Int] {
    let n:Int = arr.len();
    let mut i:Int = 0;
    let mut j:Int = n - 1;
    while i < j {
        swap(arr, i, j);
        i = i + 1;
        j = j - 1;
    }
    return arr;
}

pub fn bubbleSort(arr: [Int]) -> [Int] {
    let n:Int = arr.len();
    let mut i:Int = 0;
    while i < n {
        let mut j:Int = 0;
        while j < n - i - 1 {
            if arr[j] > arr[j + 1] {
                swap(arr, j, j + 1);
            }
            j = j + 1;
        }
        i = i + 1;
    }
    return arr;
}

pub fn quickSort(arr: [Int], low: Int, high: Int) -> [Int] {
    if low < high {
        let pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
    return arr;
}

fn partition(arr: [Int], low: Int, high: Int) -> Int {
    let pivot = arr[high];
    let mut i = low - 1;
    let mut j = low;
    while j < high {
        if arr[j] < pivot {
            i = i + 1;
            swap(arr, i, j);
        }
        j = j + 1;
    }
    swap(arr, i + 1, high);
    return i + 1;
}
